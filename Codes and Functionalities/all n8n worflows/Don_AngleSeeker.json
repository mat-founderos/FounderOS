{
  "name": "Don_AngleSeeker",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -2240,
        1168
      ],
      "id": "d6c7ab53-174a-48b5-a8fe-74e0ae21d6b6",
      "name": "When clicking â€˜Execute workflowâ€™"
    },
    {
      "parameters": {
        "content": "## EXECUTE ONLY ONCE",
        "height": 320,
        "width": 656,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -2416,
        592
      ],
      "typeVersion": 1,
      "id": "e387b210-22c1-48c2-8ce1-761b67c9cc4f",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "CREATE TABLE IF NOT EXISTS reddit_posts (\n  id bigserial PRIMARY KEY,\n\n  reddit_id text,\n  name_full text,\n\n  subreddit text,\n  subreddit_id text,\n  post_title text,\n  post_text text,\n  post_url text,\n  post_category text,\n\n  post_status text NOT NULL DEFAULT 'OPEN',\n\n  ups integer,\n  num_comments integer,\n  post_date date,\n  post_author text,\n\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now()\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2368,
        688
      ],
      "id": "1494a844-caa6-4497-87ff-f2309a1ac6bf",
      "name": "reddit_posts Table"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "/* Updated reddit_comments table with AI analysis fields */\nCREATE TABLE IF NOT EXISTS reddit_comments (\n  id bigserial PRIMARY KEY,\n\n  subreddit_id text,\n  subreddit text,\n  reddit_id text,\n  reddit_comment_id text, \n  author text,\n  body text,\n  parent_comment_id text,\n  depth integer,\n  replies_kind text,\n\n  /* AI enrichment fields */\n  ai_category text,\n  key_themes text[],  -- Array of identified themes\n  juicy_copy text[],  -- Array of extracted quotes\n  theme_frequency jsonb,  -- {\"theme_name\": count, ...}\n  ai_analysis jsonb,  -- Full structured analysis from agents\n\n  created_at timestamptz DEFAULT now(),\n  updated_at timestamptz DEFAULT now()\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -2176,
        688
      ],
      "id": "af5cfb7d-4abe-4d8b-9f85-0a46aa2f7a0e",
      "name": "reddit_comments Table"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "CREATE TABLE reddit_analysis_summary (\n  id SERIAL PRIMARY KEY,\n  analysis_date TIMESTAMP DEFAULT NOW(),\n  campaign_name VARCHAR(100),\n  processing_summary JSONB,\n  aggregated_themes JSONB,\n  key_insights JSONB,\n  total_comments_analyzed INTEGER,\n  google_doc_url TEXT,\n  created_at TIMESTAMP DEFAULT NOW()\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1984,
        688
      ],
      "id": "a32b61ce-f258-403e-83d0-ba384825c8ba",
      "name": "reddit_analysis_summary Table"
    },
    {
      "parameters": {
        "operation": "getAll",
        "subreddit": "[your-chosen-subbredit]",
        "limit": 20,
        "filters": {
          "category": "new"
        }
      },
      "type": "n8n-nodes-base.reddit",
      "typeVersion": 1,
      "position": [
        -1968,
        1296
      ],
      "id": "c3262856-ad03-4971-85fc-48ebe5515b3a",
      "name": "Get many posts3"
    },
    {
      "parameters": {
        "resource": "postComment",
        "operation": "getAll",
        "subreddit": "={{ $json.subreddit }}",
        "postId": "={{ $json.reddit_id }}",
        "returnAll": true
      },
      "type": "n8n-nodes-base.reddit",
      "typeVersion": 1,
      "position": [
        -864,
        1632
      ],
      "id": "52e281a5-83c9-4cf5-ae30-c541c3143d1e",
      "name": "Get many comments in a post3",
      "notesInFlow": true,
      "notes": "get comments on posts"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "options": {
          "temperature": 0.7
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        1264,
        1072
      ],
      "id": "ccd97c4e-d5ad-467c-ace2-7bbdbe4645be",
      "name": "OpenAI Chat Model8"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n    \"Category\": \"<One of 13 predefined categories>\",\n    \"Key Theme\": \"<Normalized key idea>\",\n    \"Juicy Copy\": \"<Verbatim full sentence quote from the response>\"\n}\n\n"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1504,
        1088
      ],
      "id": "99d8c3cd-6496-42aa-8232-d1ddc056ead8",
      "name": "Structured Output Parser8"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {}
          ]
        }
      },
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [
        -2256,
        1424
      ],
      "id": "0f297298-c1c4-4b3f-a1d4-933d6a1e580e",
      "name": "Schedule Trigger3",
      "disabled": true
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 2,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "0823d10a-ad54-4d82-bcea-9dd236e97857",
              "operator": {
                "type": "number",
                "operation": "gt"
              },
              "leftValue": "={{ $json.ups }}",
              "rightValue": 1
            },
            {
              "id": "bb8187aa-f0f1-4999-8d4b-bdc9abba0618",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              },
              "leftValue": "={{ $json.selftext }}",
              "rightValue": ""
            },
            {
              "id": "539f0f5c-025a-4f82-9b3a-2ef1ad3a2d96",
              "operator": {
                "type": "dateTime",
                "operation": "after"
              },
              "leftValue": "={{ DateTime.fromSeconds($json.created).toISO() }}",
              "rightValue": "={{ $today.minus(5,'days').toISO() }}"
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "dba5210d-f0e2-40e1-9a66-49006d54c411",
      "name": "Filter Posts By Features3",
      "type": "n8n-nodes-base.if",
      "position": [
        -1552,
        1296
      ],
      "typeVersion": 2.2
    },
    {
      "parameters": {
        "jsCode": "// Get the input data from the previous node\nconst inputData = $input.all();\n\n// Define the specific body text to remove (first part to identify it)\nconst discordIdentifier = \"#####[Join the r/FulfillmentByAmazon Discord Server!]\";\n\n// Function to check if a body contains the Discord invitation\nfunction isDiscordBody(bodyText) {\n  if (!bodyText) return false;\n  \n  // Check if the body starts with our Discord identifier\n  return bodyText.trim().startsWith(discordIdentifier);\n}\n\n// Debug: Log the total number of items and structure\nconsole.log(\"Total input items:\", inputData.length);\n\n// Filter out items with the Discord body\nconst filteredData = inputData.filter((item, index) => {\n  // Get the body value from different possible structures\n  let bodyValue = null;\n  \n  if (item.json && item.json.body) {\n    bodyValue = item.json.body;\n  } else if (item.body) {\n    bodyValue = item.body;\n  }\n  \n  // Check if this is a Discord body\n  const isDiscord = isDiscordBody(bodyValue);\n  \n  // Debug: Log when we find a Discord body\n  if (isDiscord) {\n    console.log(`Found Discord body at index ${index}, removing it`);\n  }\n  \n  // Return true to KEEP the item (i.e., return false for Discord bodies)\n  return !isDiscord;\n});\n\nconsole.log(\"Filtered items count:\", filteredData.length);\nconsole.log(\"Removed items:\", inputData.length - filteredData.length);\n\n// Return the filtered data\nreturn filteredData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -384,
        1632
      ],
      "id": "9ae67d6a-846c-4c78-808c-58703c38808f",
      "name": "Remove the Discord Channel Ad comment3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        -1552,
        1520
      ],
      "id": "9fb3c088-3adc-427a-a924-c70425426aca",
      "name": "No Operation, do nothing5"
    },
    {
      "parameters": {
        "content": "## Reddit Comment Data Extractor\n**âŒ Problem: Shows how complex and messy raw Reddit data is (50+ fields, deep nesting)\nâœ… Solution: Explains the 4 key functions:\n- Data flattening (nested â†’ flat)\n- Essential field extraction (50+ fields â†’ 7 fields)\n- Relationship preservation (parent-child links)\n- Recursive processing (handles unlimited nesting)\n\nðŸŽ¯ Benefits: Clear metrics showing 90% data reduction, database optimization, and performance gains",
        "height": 432,
        "width": 416
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -528,
        1360
      ],
      "typeVersion": 1,
      "id": "4ec184c9-1df4-400e-be5e-275b1fe044da",
      "name": "Sticky Note15"
    },
    {
      "parameters": {
        "jsCode": "// Get the input data from the previous node\nconst inputData = $input.all();\n\n// Function to recursively extract only the essential comment data\nfunction extractComments(comments, parentId = null, depth = 0) {\n  const result = [];\n  \n  if (!comments || !Array.isArray(comments)) {\n    return result;\n  }\n  \n  comments.forEach(comment => {\n    // Extract only essential comment data\n    const commentData = {\n      id: comment.id,\n      subreddit_id: comment.subreddit_id,\n      subreddit: comment.subreddit,\n      author: comment.author,\n      body: comment.body,\n      parent_id: parentId, // Our custom parent tracking for relationships\n      depth: depth,\n      replies_kind: null\n    };\n    \n    // Add the main comment to results\n    result.push(commentData);\n    \n    // Process replies if they exist\n    if (comment.replies && typeof comment.replies === 'object' && comment.replies.data) {\n      commentData.replies_kind = comment.replies.kind;\n      \n      const children = comment.replies.data.children || [];\n      \n      // Recursively process replies\n      children.forEach(child => {\n        if (child.data) {\n          const childComments = extractComments([child.data], comment.id, depth + 1);\n          result.push(...childComments);\n        }\n      });\n    }\n  });\n  \n  return result;\n}\n\n// Process all input data\nlet allComments = [];\n\ninputData.forEach((item, index) => {\n  console.log(`Processing item ${index + 1}/${inputData.length}`);\n  \n  // Handle different possible data structures\n  let comments = [];\n  \n  if (item.json && Array.isArray(item.json)) {\n    comments = item.json;\n  } else if (Array.isArray(item)) {\n    comments = item;\n  } else if (item.json) {\n    comments = [item.json];\n  } else {\n    comments = [item];\n  }\n  \n  // Extract comments from this item\n  const extractedComments = extractComments(comments);\n  allComments.push(...extractedComments);\n});\n\nconsole.log(`Extracted ${allComments.length} comments`);\nconsole.log(\"Sample comment:\", allComments[0]);\n\n// Return only the essential data\nreturn allComments;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        96,
        1632
      ],
      "id": "93fc2db7-ccb8-47e6-ae4f-fff8b492dbc5",
      "name": "Reddit Comment Data Extractor3"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "325a45b6-e5e3-47f5-a620-9db9035d60e1",
              "name": "post_text",
              "value": "={{ $json.selftext }}",
              "type": "string"
            },
            {
              "id": "3aa2322a-b25c-4850-9330-e922a2121fc4",
              "name": "post_title",
              "value": "={{ $json.title }}",
              "type": "string"
            },
            {
              "id": "7f7ed13f-0947-4d6e-9474-5d3097cc2b27",
              "name": "ups",
              "value": "={{ $json.ups }}",
              "type": "number"
            },
            {
              "id": "3d51f56d-7323-462a-b9b9-3aa4b1509cb7",
              "name": "post_url",
              "value": "=https://www.reddit.com{{ $json.permalink }}",
              "type": "string"
            },
            {
              "id": "60635d19-c6b0-48d4-9ec1-09cabb1195bb",
              "name": "subreddit",
              "value": "={{ $json.subreddit }}",
              "type": "string"
            },
            {
              "id": "66f38835-0f3e-4be4-a6e7-d287322c579e",
              "name": "post_category",
              "value": "={{ $json.link_flair_text }}",
              "type": "string"
            },
            {
              "id": "c987ee9e-6351-444b-8fb6-7947d1c70c2a",
              "name": "num_comments",
              "value": "={{ $json.num_comments }}",
              "type": "number"
            },
            {
              "id": "a3130fbe-4e95-4c8f-85c7-f4fc0b941a64",
              "name": "post_date",
              "value": "={{ DateTime.fromSeconds($json.created_utc).toFormat('dd.MM.yyyy') }}",
              "type": "string"
            },
            {
              "id": "5956163b-b412-47b8-a0df-931786882af7",
              "name": "post_author",
              "value": "={{ $json.author }}",
              "type": "string"
            },
            {
              "id": "c3966f6c-3d32-4954-bef4-bcbe5dba5ec3",
              "name": "subreddit_id",
              "value": "={{ $json.subreddit_id }}",
              "type": "string"
            },
            {
              "id": "044427e2-8416-4e4a-bdd0-7098001f74e6",
              "name": "post_id",
              "value": "={{ $json.id }}",
              "type": "string"
            },
            {
              "id": "042f143b-4762-4101-88f5-50539e051958",
              "name": "author_fullname",
              "value": "={{ $json.author_fullname }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1296,
        1280
      ],
      "id": "e52ed787-65db-4ac6-a5e9-47e8d600c2ff",
      "name": "Post Metadata3",
      "notesInFlow": true,
      "notes": "leave only field needed"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "loose",
            "version": 2
          },
          "conditions": [
            {
              "id": "9fb0a3ff-ab19-414c-b5b3-fcfe763bb3af",
              "leftValue": "={{ $json.num_comments }}",
              "rightValue": 10,
              "operator": {
                "type": "number",
                "operation": "gte"
              }
            }
          ],
          "combinator": "and"
        },
        "looseTypeValidation": true,
        "options": {}
      },
      "type": "n8n-nodes-base.filter",
      "typeVersion": 2.2,
      "position": [
        -1760,
        1296
      ],
      "id": "cc6667b5-1d5a-4c44-bbd7-f09caeac973c",
      "name": "Filter comments less than 2"
    },
    {
      "parameters": {
        "tableId": "reddit_posts",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "post_text",
              "fieldValue": "={{ $json.post_text }}"
            },
            {
              "fieldId": "post_title",
              "fieldValue": "={{ $json.post_title }}"
            },
            {
              "fieldId": "subreddit_id",
              "fieldValue": "={{ $json.subreddit_id }}"
            },
            {
              "fieldId": "subreddit",
              "fieldValue": "={{ $json.subreddit }}"
            },
            {
              "fieldId": "ups",
              "fieldValue": "={{ $json.ups }}"
            },
            {
              "fieldId": "post_url",
              "fieldValue": "={{ $json.post_url }}"
            },
            {
              "fieldId": "post_category",
              "fieldValue": "={{ $json.post_category }}"
            },
            {
              "fieldId": "num_comments",
              "fieldValue": "={{ $json.num_comments }}"
            },
            {
              "fieldId": "post_date",
              "fieldValue": "={{ $json.post_date }}"
            },
            {
              "fieldId": "post_author",
              "fieldValue": "={{ $json.post_author }}"
            },
            {
              "fieldId": "reddit_id",
              "fieldValue": "={{ $json.post_id }}"
            },
            {
              "fieldId": "name_full",
              "fieldValue": "={{ $json.author_fullname }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1088,
        1280
      ],
      "id": "5e65d35b-d02d-4923-a395-c6f84ab20694",
      "name": "Create a row in reddit_posts Table3"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "reddit_comments",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "condition": "eq",
              "keyValue": "={{ $('Loop Over Post Comments').item.json.id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "ai_category",
              "fieldValue": "={{ $json.output.Category }}"
            },
            {
              "fieldId": "key_themes",
              "fieldValue": "={{ [$json.output[\"Key Theme\"]] }}"
            },
            {
              "fieldId": "juicy_copy",
              "fieldValue": "={{ [$json.output[\"Juicy Copy\"]] }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1696,
        864
      ],
      "id": "c760b44b-2b94-4a0c-9c7b-c775fa502e28",
      "name": "Update a row4",
      "retryOnFail": true,
      "waitBetweenTries": 5000,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {},
      "type": "@n8n/n8n-nodes-langchain.toolThink",
      "typeVersion": 1.1,
      "position": [
        1536,
        576
      ],
      "id": "b8bc2eea-c1f3-466a-a809-d6fc96b7a12c",
      "name": "Think3"
    },
    {
      "parameters": {
        "jsCode": "// Filter out comments with less than 5 words\nconst filteredItems = [];\n\nfor (const item of $input.all()) {\n  const comment = item.json.comment || item.json.body || item.json.text;\n  \n  if (comment) {\n    // Clean up the text and count words\n    const wordCount = comment\n      .trim()\n      .replace(/\\s+/g, ' ') // Replace multiple spaces with single space\n      .split(' ')\n      .filter(word => word.length > 0) // Remove empty strings\n      .length;\n    \n    if (wordCount >= 5) {\n      filteredItems.push(item);\n    }\n  }\n}\n\nreturn filteredItems;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        592,
        1632
      ],
      "id": "1d660545-4811-4487-ac2e-1f19935b005e",
      "name": "Filter out comments with less than 5 words3"
    },
    {
      "parameters": {
        "tableId": "reddit_comments",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "reddit_comment_id",
              "fieldValue": "={{ $json.id }}"
            },
            {
              "fieldId": "subreddit_id",
              "fieldValue": "={{ $json.subreddit_id }}"
            },
            {
              "fieldId": "subreddit",
              "fieldValue": "={{ $json.subreddit }}"
            },
            {
              "fieldId": "author",
              "fieldValue": "={{ $json.author }}"
            },
            {
              "fieldId": "body",
              "fieldValue": "={{ $json.body }}"
            },
            {
              "fieldId": "parent_comment_id",
              "fieldValue": "={{ $json.parent_id }}"
            },
            {
              "fieldId": "depth",
              "fieldValue": "={{ $json.depth }}"
            },
            {
              "fieldId": "replies_kind",
              "fieldValue": "={{ $json.replies_kind }}"
            },
            {
              "fieldId": "reddit_id",
              "fieldValue": "={{ ($('Get many comments in a post3').first().json.parent_id ?? '').replace(/^[^_]*_/, '') }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -1152,
        1744
      ],
      "id": "aec5f3af-81dc-4a84-a9e3-d0cd77800e8d",
      "name": "Create a row in reddit_comments Table3"
    },
    {
      "parameters": {
        "content": "## Duplicate Detection & Data Preservation System\n\nChecks if each Reddit comment already exists in the database to prevent duplicates.",
        "height": 368,
        "width": 320,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        480,
        1424
      ],
      "typeVersion": 1,
      "id": "871b269c-d6af-41ab-a632-b1516052d5e4",
      "name": "Sticky Note19"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT COUNT(*) as exists_count \nFROM reddit_comments \nWHERE reddit_comment_id = '{{ $json.id }}'",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        1040,
        1632
      ],
      "id": "500c729c-e85d-46a4-96d1-a45fe31cf5d9",
      "name": "Check for Duplicates in reddit_comments Table3"
    },
    {
      "parameters": {
        "content": "## Code (Data Merger)\n\nChecks if each Reddit comment already exists in the database to prevent duplicates.\nFunction:\n\nQueries the reddit_comments table using the comment's unique reddit_comment_id\nReturns exists_count: \"1\" if record exists, \"0\" if new\nProcesses each item individually to maintain data integrity\n\nQuery: SELECT COUNT(*) as exists_count FROM reddit_comments WHERE reddit_comment_id = '{{ $json.id }}'",
        "height": 496,
        "width": 528,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        832,
        1296
      ],
      "typeVersion": 1,
      "id": "0977b266-d5c7-429f-bca8-371ff2bd814c",
      "name": "Sticky Note20"
    },
    {
      "parameters": {
        "jsonSchemaExample": "{\n  \"processing_summary\": {\n    \"total_reviews\": \"number\",\n    \"unique_themes\": \"number\",\n    \"total_occurrences\": \"number\"\n  },\n  \"aggregated_themes\": [\n    {\n      \"category\": \"string\",\n      \"key_theme\": \"string\",\n      \"frequency\": \"number\",\n      \"juicy_copy\": [\"string\"]\n    }\n  ],\n  \"key_insights\": {\n    \"top_audience\": \"string\",\n    \"top_benefits\": \"string\",\n    \"main_objections\": \"string\",\n    \"emotional_drivers\": \"string\"\n  },\n  \"table_markdown\": \"string\",\n  \"report_markdown\": \"string\"\n}"
      },
      "type": "@n8n/n8n-nodes-langchain.outputParserStructured",
      "typeVersion": 1.3,
      "position": [
        1648,
        528
      ],
      "id": "aaa1a4f8-a991-424f-a760-75d74895f76e",
      "name": "Structured Output Parser9"
    },
    {
      "parameters": {
        "tableId": "reddit_analysis_summary",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "analysis_date",
              "fieldValue": "={{ new Date().toISOString() }}"
            },
            {
              "fieldId": "campaign_name",
              "fieldValue": "=Reddit_Analysis_{{ $('Loop Over Post Comments').first().json.subreddit }}"
            },
            {
              "fieldId": "processing_summary",
              "fieldValue": "={{ $json.output.processing_summary }}"
            },
            {
              "fieldId": "aggregated_themes",
              "fieldValue": "={{ $json.output.aggregated_themes }}"
            },
            {
              "fieldId": "key_insights",
              "fieldValue": "={{ $json.output.key_insights }}"
            },
            {
              "fieldId": "total_comments_analyzed",
              "fieldValue": "={{ $json.output.processing_summary.total_reviews }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1776,
        336
      ],
      "id": "eb3f44d3-8607-4df8-90b9-54e9e0f434b5",
      "name": "Create a row in reddit_analysis_summary Table6"
    },
    {
      "parameters": {
        "operation": "createFromText",
        "content": "={{ $json.formatted_content }}",
        "name": "={{ $json.filename }}",
        "driveId": {
          "__rl": true,
          "value": "My Drive",
          "mode": "list",
          "cachedResultName": "My Drive",
          "cachedResultUrl": "https://drive.google.com/drive/my-drive"
        },
        "folderId": {
          "__rl": true,
          "mode": "list",
          "value": "root",
          "cachedResultName": "/ (Root folder)"
        },
        "options": {
          "convertToGoogleDocument": false
        }
      },
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        1888,
        96
      ],
      "id": "2b4f1b7e-a688-485f-9d63-d0617c50398a",
      "name": "Create file from text3"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=={{ typeof $json.data === 'string' ? $json.data : JSON.stringify($json.data, null, 0) }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "ROLE & GOAL\nYou are AnalyticsAggregator AI, a world-class data analyst specializing in consolidating voice-of-customer analysis into executive-ready reports.\n\nINPUT SHAPE\nYou receive a JSON-encoded array of comment analyses. Each item may include:\n- ai_category: string (one of the 13 diagnostic categories)\n- key_themes: string OR array of strings (theme names found in the comment)\n- juicy_copy: string OR array of strings (representative quotes)\n\nTASK\n1) Normalize & Group\n   - Normalize theme names (trim, lowercase for matching, title-case for display).\n   - Merge semantically identical themes under one consistent â€œkey_themeâ€ (e.g., â€œsleep improvementâ€ vs â€œbetter sleepâ€ â†’ â€œSleep improvementâ€).\n   - Group by (ai_category, key_theme).\n\n2) Count Frequencies\n   - For each (category, theme) pair, count how many input items support it.\n   - Keep the most representative 1â€“3 quotes (short, vivid, non-duplicated).\n\n3) Build Aggregates\n   - Construct an array `aggregated_themes` with objects:\n     { category, key_theme, frequency, juicy_copy[] }\n   - Sort by frequency descending (and by category alphabetically as a tiebreaker).\n\n4) Processing Summary\n   - processing_summary.total_reviews = number of input items\n   - processing_summary.unique_themes = distinct (category, theme) pairs\n   - processing_summary.total_occurrences = sum of all frequencies\n\n5) Key Insights\n   - top_audience: whoâ€™s speaking / pattern of audience if visible\n   - top_benefits: most frequent benefits or outcomes\n   - main_objections: most frequent objections/hesitations\n   - emotional_drivers: emotions that recur across comments\n\n6) Table Generation (TOOL CALL)\n   - Call the tool `build_md_table` with the final aggregated themes to produce a Markdown table.\n     Pass JSON of the form: { \"themes\": aggregated_themes }\n   - Put the returned string into `table_markdown`.\n\n7) Compose Report Markdown\n   - report_markdown must be a COMPLETE, human-readable report:\n     # REDDIT COMMENT ANALYSIS REPORT\n     ## PROCESSING SUMMARY\n     (bullets or short lines using the processing_summary numbers)\n     ## AGGREGATED THEMES TABLE\n     (include table_markdown verbatim)\n     ## KEY INSIGHTS\n     (bulleted list summarizing top_audience, top_benefits, main_objections, emotional_drivers)\n\nCONSTRAINTS\n- DO NOT invent themes or quotes; only use content given in the input.\n- Prefer short, vivid quotes; clip to ~140 chars.\n- If key_themes/juicy_copy are missing or null, skip them for that item.\n- Always return JSON ONLY using the exact fields required by the output schema.\n\nOUTPUT (STRICT)\nReturn JSON with exactly these fields:\n{\n  \"processing_summary\": {\n    \"total_reviews\": number,\n    \"unique_themes\": number,\n    \"total_occurrences\": number\n  },\n  \"aggregated_themes\": [\n    { \"category\": string, \"key_theme\": string, \"frequency\": number, \"juicy_copy\": [string, ...] }\n  ],\n  \"key_insights\": {\n    \"top_audience\": string,\n    \"top_benefits\": string,\n    \"main_objections\": string,\n    \"emotional_drivers\": string\n  },\n  \"table_markdown\": string,\n  \"report_markdown\": string\n}\n\nStrict typing: Return all counts and frequencies as numbers (not strings)."
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        1312,
        320
      ],
      "id": "3e4fe4ed-7db6-4366-bff9-abc405cc3d97",
      "name": "Summary Agent3"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        1712,
        1072
      ],
      "id": "c60e09a1-43d0-4acc-9ccf-5cee8a39913b",
      "name": "Wait 5sec4",
      "webhookId": "9ec4f861-967e-44e8-a4ee-87f55de0c7c9"
    },
    {
      "parameters": {
        "jsCode": "// Robust formatter: Summary + Table + Detailed Themes (by category) + Insights\n// Works even if the agent forgets to build table_markdown\n\nconst data = $json.output || $json || {};\n\nfunction toNum(n){ const v = Number(n); return Number.isFinite(v) ? v : 0; }\nfunction hasTableRows(md){ return typeof md === 'string' && md.trim().split('\\n').length > 2; }\n\n// Fallback table builder from aggregated themes\nfunction buildTableFromThemes(themes){\n  const arr = Array.isArray(themes) ? themes.slice() : [];\n  const esc = s => String(s ?? '').replace(/\\|/g,'\\\\|').replace(/\\n/g,' ');\n  const clip = (s, n=140) => { s = String(s ?? ''); return s.length>n ? s.slice(0,n-1)+'â€¦' : s; };\n  arr.sort((a,b)=>{\n    const fa = toNum(a?.frequency), fb = toNum(b?.frequency);\n    if(fb!==fa) return fb-fa;\n    const ca=(a?.category??'').toLowerCase(), cb=(b?.category??'').toLowerCase();\n    if(ca!==cb) return ca<cb?-1:1;\n    const ta=(a?.key_theme??'').toLowerCase(), tb=(b?.key_theme??'').toLowerCase();\n    return ta<tb?-1:ta>tb?1:0;\n  });\n  const header = ['| Category | Theme | Frequency | Quotes |','|---|---|---:|---|'];\n  const rows = arr.map(t=>{\n    const quotes = (Array.isArray(t?.juicy_copy)?t.juicy_copy:[])\n      .filter(Boolean).slice(0,2).map(q=>clip(q)).join(' â€¢ ');\n    return `| ${esc(t?.category)} | ${esc(t?.key_theme)} | ${toNum(t?.frequency)} | ${esc(quotes)} |`;\n  });\n  return header.concat(rows).join('\\n');\n}\n\n// Build detailed section (your old style) grouped by category\nfunction buildDetailedSection(themes){\n  if(!Array.isArray(themes) || themes.length===0) return 'No themes data available';\n  const clip = (s, n=200) => { s = String(s ?? ''); return s.length>n ? s.slice(0,n-1)+'â€¦' : s; };\n  const byCat = themes.reduce((m,t)=>{\n    const cat = (t?.category || 'Uncategorized').toUpperCase();\n    (m[cat] ||= []).push(t);\n    return m;\n  }, {});\n  const parts = [];\n  Object.keys(byCat).sort().forEach(cat=>{\n    parts.push(`\\n### ${cat}`);\n    byCat[cat].forEach(t=>{\n      parts.push(`**Theme:** ${t?.key_theme ?? ''}`);\n      parts.push(`**Frequency:** ${toNum(t?.frequency)}`);\n      const quotes = Array.isArray(t?.juicy_copy) ? t.juicy_copy.filter(Boolean) : [];\n      parts.push(`**Representative Quotes:**\\n${quotes.length ? quotes.slice(0,3).map(q=>`â€¢ \"${clip(q)}\"`).join('\\n') : 'â€¢ No quotes available'}\\n`);\n    });\n  });\n  return parts.join('\\n');\n}\n\n// 1) Decide table to print\nlet tableMd = data.table_markdown;\nif(!hasTableRows(tableMd)) tableMd = buildTableFromThemes(data.aggregated_themes);\n\n// 2) Build detailed themes section\nconst detailed = buildDetailedSection(data.aggregated_themes);\n\n// 3) Compose final doc (prefer agentâ€™s numbers/insights)\nconst pr = data.processing_summary || {};\nconst total = toNum(pr.total_reviews), uniq = toNum(pr.unique_themes), occ = toNum(pr.total_occurrences);\nconst ki = data.key_insights || {};\n\nconst docContent = `# REDDIT COMMENT ANALYSIS REPORT\n## PROCESSING SUMMARY\n- Total Reviews Analyzed: ${total}\n- Unique Themes Identified: ${uniq}\n- Total Theme Occurrences: ${occ}\n\n## AGGREGATED THEMES TABLE\n${tableMd}\n\n## DETAILED THEMES\n${detailed}\n\n## KEY INSIGHTS\n- **Top Audience**: ${ki.top_audience || 'N/A'}\n- **Top Benefits**: ${ki.top_benefits || 'N/A'}\n- **Main Objections**: ${ki.main_objections || 'N/A'}\n- **Emotional Drivers**: ${ki.emotional_drivers || 'N/A'}\n`;\n\nreturn [{\n  json: {\n    formatted_content: docContent,\n    // TIP: set convertToGoogleDocument=true in the Google Drive node if you want a .gdoc\n    filename: `Reddit_Analysis_${new Date().toISOString().split('T')[0]}_${Date.now()}`\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1664,
        96
      ],
      "id": "b512514b-8bcb-4c4a-aae5-1fe7b77bf119",
      "name": "Format the AI output for Google Doc3"
    },
    {
      "parameters": {
        "operation": "get",
        "tableId": "reddit_comments",
        "filters": {
          "conditions": [
            {
              "keyName": "id",
              "keyValue": "={{ $json.id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        720,
        896
      ],
      "id": "12506486-c991-422e-ad91-379df935f644",
      "name": "Get a row4"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "1195341f-2bb9-485f-a05d-6f98e9bf688a",
              "leftValue": "={{ $json.juicy_copy }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notExists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        1072,
        896
      ],
      "id": "c6c93619-600a-48b6-be3f-4cc045737b9d",
      "name": "If8"
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "include": "specifiedFields",
        "fieldsToInclude": "key_themes, juicy_copy, ai_category",
        "options": {}
      },
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [
        704,
        320
      ],
      "id": "0638d9e9-185d-4649-a7da-e469bc4320f3",
      "name": "Aggregate3"
    },
    {
      "parameters": {
        "jsCode": "// Get the document ID from the previous node\nconst docId = $input.item.json.id;\n\n// Construct the Google Docs URL using the ID\nconst docUrl = `https://docs.google.com/document/d/${docId}/edit`;\n\n// Return the original item with the added URL\nreturn {\n  ...$input.item.json,\n  documentUrl: docUrl\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2112,
        96
      ],
      "id": "d8216ed5-a23f-4fa5-aead-d17b87c9637f",
      "name": "Get Google Doc URL3"
    },
    {
      "parameters": {
        "tableId": "reddit_analysis_summary",
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "analysis_date",
              "fieldValue": "={{ new Date().toISOString() }}"
            },
            {
              "fieldId": "campaign_name",
              "fieldValue": "=Reddit_Analysis_{{ $('Loop Over Post Comments').first().json.subreddit }}"
            },
            {
              "fieldId": "processing_summary",
              "fieldValue": "={{ $json.output.processing_summary }}"
            },
            {
              "fieldId": "aggregated_themes",
              "fieldValue": "={{ $json.output.aggregated_themes }}"
            },
            {
              "fieldId": "key_insights",
              "fieldValue": "={{ $json.output.key_insights }}"
            },
            {
              "fieldId": "total_comments_analyzed",
              "fieldValue": "={{ $json.output.processing_summary.total_reviews }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        2368,
        176
      ],
      "id": "65ef604c-e2e8-4f30-8a6e-e2cc73965c74",
      "name": "Create a row in reddit_analysis_summary Table7"
    },
    {
      "parameters": {
        "content": "## Safe to re-run\n**Why we do it**\n- Makes the pipeline resumable. If n8n or an API crashes mid-run, you can rerun the workflow and it will pick up only the unfinished comments.\n- Prevents double charges and duplicate work by not sending the same text to the AI twice.\n- Keeps the DB as the single source of truth for processing state (status), so the control flow is simple and robust.\n\n**Benefits**\n- Idempotent: run it again and again; results wonâ€™t be duplicated.\n- Cost control: the AI Agent is called only for items that truly need it.\n- Reliability: easy recovery from partial failures or timeouts.\n- Throughput friendly: the small wait smooths spikes and reduces 429s.",
        "height": 512,
        "width": 496,
        "color": 5
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        528,
        528
      ],
      "typeVersion": 1,
      "id": "51b11275-ac33-4054-9db2-a8bab04ae969",
      "name": "Sticky Note21"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "reddit_posts",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "post_status",
              "condition": "eq",
              "keyValue": "OPEN"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        -528,
        368
      ],
      "id": "20b2c51e-5a6c-45c6-a2cb-858954965c7d",
      "name": "Get many rows"
    },
    {
      "parameters": {
        "jsCode": "// Mode: Run once for all items\nconst total = $input.all().length;\nreturn [{ json: { gate: true, total_in: total } }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        368
      ],
      "id": "893cec40-4d60-4976-89bc-7cbf6ac791f7",
      "name": "Code"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        2288,
        592
      ],
      "id": "71d72dbe-4c72-4b59-b52b-b5fd6d0a3b46",
      "name": "Merge"
    },
    {
      "parameters": {
        "operation": "update",
        "tableId": "reddit_posts",
        "filters": {
          "conditions": [
            {
              "keyName": "reddit_id",
              "condition": "eq",
              "keyValue": "={{ $('Loop Over Post Comments').first().json.reddit_id }}"
            }
          ]
        },
        "fieldsUi": {
          "fieldValues": [
            {
              "fieldId": "post_status",
              "fieldValue": "DONE"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        1984,
        336
      ],
      "id": "e6065545-24a5-4ce5-ab94-554036e306d1",
      "name": "Update status=DONE in reddit_post Table"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "6f1c6d32-4c14-4a17-9656-cd87291c55fc",
              "leftValue": "={{ $json.exists_count }}",
              "rightValue": "1",
              "operator": {
                "type": "string",
                "operation": "notEquals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -336,
        1872
      ],
      "id": "2852839c-517e-43cd-9e27-77c0f617de3e",
      "name": "If comment exists (no = True Branch)"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -832,
        1264
      ],
      "id": "d2ca2d34-4227-4713-95a3-811e0803bfdb",
      "name": "Loop Over Posts"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        416,
        336
      ],
      "id": "77602ba0-d5f3-4034-b2fa-851bb0901b38",
      "name": "Loop Over Post Comments"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        -320,
        368
      ],
      "id": "7b9eb3fe-227a-49de-8c38-c02a1a5bf72f",
      "name": "Posts with status==OPEN"
    },
    {
      "parameters": {
        "operation": "getAll",
        "tableId": "reddit_comments",
        "returnAll": true,
        "filters": {
          "conditions": [
            {
              "keyName": "reddit_id",
              "condition": "eq",
              "keyValue": "={{ $json.reddit_id }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.supabase",
      "typeVersion": 1,
      "position": [
        80,
        336
      ],
      "id": "585daf32-ac87-4a2e-870f-7cb9b657c601",
      "name": "Get many rows from reddit_comments Table"
    },
    {
      "parameters": {
        "jsCode": "// Get the original data from the Filter node\nconst originalData = $('Filter out comments with less than 5 words3').all();\n// Get the exists check results\nconst existsData = $input.all();\n\nconst mergedData = [];\n\nfor (let i = 0; i < originalData.length; i++) {\n  mergedData.push({\n    json: {\n      ...originalData[i].json,  // All original comment data\n      exists_count: existsData[i].json.exists_count  // Add the exists check\n    }\n  });\n}\n\nreturn mergedData;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1408,
        1632
      ],
      "id": "a90eba02-a43c-472f-874f-6febc98bf870",
      "name": "Merge the result from the last 2 nodes3"
    },
    {
      "parameters": {
        "content": "## CALL POSTS with Status == OPEN\n**We will place each post in a Loop, where the AngleFinder AI Agent will categorize it, and then the Summary Agent will generate a report on the current post. ",
        "height": 352,
        "width": 400
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -560,
        208
      ],
      "typeVersion": 1,
      "id": "318b78ff-cc61-4293-a3b0-a8a9b44d4c7a",
      "name": "Sticky Note11"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-pro",
        "options": {
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        1264,
        528
      ],
      "id": "822e8312-fa3b-4478-ad11-4d488dc24a20",
      "name": "Google Gemini Chat Model"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.gmail",
      "typeVersion": 2.1,
      "position": [
        224,
        0
      ],
      "id": "3143cd40-b9ee-47e9-93ad-07944c90b004",
      "name": "Send a message",
      "webhookId": "a574cdd3-ad95-453e-932e-0ece1ae1b9f3",
      "disabled": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "Ð°ÑÐ¾Ð¶",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        0,
        0
      ],
      "id": "bb4e8821-07ea-4378-8bcf-798cc38322df",
      "name": "Execute a SQL query"
    },
    {
      "parameters": {
        "description": "Build a Markdown table from aggregated themes (columns: Category | Theme | Frequency | Quotes). Sort by frequency desc. Clip quotes.",
        "jsCode": "// Build a Markdown table from aggregated themes.\n// Accepts either { themes: [...] } or just [...] as the tool input.\n// Returns a Markdown string.\n//\n// Expected theme objects:\n// { category: string, key_theme: string, frequency: number, juicy_copy: string[] }\n\nfunction asArray(x) {\n  if (Array.isArray(x)) return x;\n  if (x && Array.isArray(x.themes)) return x.themes;\n  if (typeof x === 'string') {\n    try { const parsed = JSON.parse(x); return asArray(parsed); } catch {}\n  }\n  return [];\n}\n\nconst input = $json ?? {};\nconst themes = asArray(input);\n\nfunction esc(s) {\n  return String(s ?? '').replace(/\\|/g, '\\\\|').replace(/\\n/g, ' ');\n}\nfunction clip(s, n = 140) {\n  s = String(s ?? '');\n  return s.length > n ? s.slice(0, n - 1) + 'â€¦' : s;\n}\n\n// sort by frequency desc, then category asc, then theme asc\nconst sorted = themes.slice().sort((a, b) => {\n  const fa = Number(a?.frequency ?? 0);\n  const fb = Number(b?.frequency ?? 0);\n  if (fb !== fa) return fb - fa;\n  const ca = (a?.category ?? '').toLowerCase();\n  const cb = (b?.category ?? '').toLowerCase();\n  if (ca !== cb) return ca < cb ? -1 : 1;\n  const ta = (a?.key_theme ?? '').toLowerCase();\n  const tb = (b?.key_theme ?? '').toLowerCase();\n  return ta < tb ? -1 : ta > tb ? 1 : 0;\n});\n\nconst header = [\n  '| Category | Theme | Frequency | Quotes |',\n  '|---|---|---:|---|',\n];\n\nconst rows = sorted.map(t => {\n  const quotes = (Array.isArray(t?.juicy_copy) ? t.juicy_copy : [])\n    .filter(Boolean)\n    .slice(0, 2)\n    .map(q => clip(q))\n    .join(' â€¢ ');\n  return `| ${esc(t?.category)} | ${esc(t?.key_theme)} | ${Number(t?.frequency ?? 0)} | ${esc(quotes)} |`;\n});\n\nreturn header.concat(rows).join('\\n');"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        1424,
        528
      ],
      "id": "d5a47a02-c007-46d7-93ce-1e8448ac3ddc",
      "name": "build_md_table"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "name": "data",
              "type": "string",
              "value": "={{ (function(){\n  const src = Array.isArray($json.data) ? $json.data : [];\n  const toArray = (v) => Array.isArray(v) ? v : (v == null ? [] : [v]);\n  const trim = (s) => (s ?? '').toString().trim();\n  const title = (s) => trim(s).toLowerCase().replace(/\\b\\w/g, c => c.toUpperCase());\n  const unique = (arr) => [...new Set(arr)];\n\n  return src.map(it => {\n    // themes: accept key_themes (array or string) or key_theme (string)\n    const themesRaw = toArray(it.key_themes ?? it.key_theme);\n    const key_themes = unique(\n      themesRaw\n        .map(t => title(t))\n        .filter(Boolean)\n    );\n\n    // quotes: accept juicy_copy (array or string) or quote(s)\n    const quotesRaw = toArray(it.juicy_copy ?? it.quote ?? it.quotes);\n    const juicy_copy = unique(\n      quotesRaw\n        .map(q => trim(q))\n        .filter(Boolean)\n    );\n\n    // category normalization\n    const rawCat = trim(it.ai_category ?? it.category ?? '');\n    const ai_category = rawCat ? title(rawCat) : 'Uncategorized';\n\n    // keep only what the agent needs\n    return { ai_category, key_themes, juicy_copy };\n  });\n})() }}"
            }
          ]
        },
        "options": {}
      },
      "id": "c7f1c27b-3b44-402d-9bd7-d55d4855f5f8",
      "name": "Normalize for Agent",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        976,
        320
      ]
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.body }}",
        "hasOutputParser": true,
        "options": {
          "systemMessage": "ROLE & GOAL\n\nYou are AngleFinder AI, a world-class research analyst and advertising strategist specializing in voice-of-customer data. Your primary goal is to transform raw customer data into a structured table of actionable advertising angles. You will meticulously analyze each customer quote, identify key themes according to a predefined framework, and extract compelling, emotionally-resonant \"Juicy Copy\" that can be used directly in marketing campaigns.\n\nCORE TASK: DO NOT Attempt to answer questions. Your task is to purely analyse & extract themes. You will process raw customer data, identifying all applicable themes and extracting quotes. You must follow these steps precisely:\n\nRead the text: Read the entire text to understand its full context.\n\nIterate Through Categories: Go through the 13 Core Categories one by one. For each category, ask yourself the associated Diagnostic Questions.\n\nIdentify & Normalize Themes:\n\nIf a diagnostic question yields a \"yes,\" a theme is present.\n\nExtract the core idea and formulate a Key Theme/Idea.\n\nNormalize this theme into a general, reusable concept. Your goal is to group semantically identical ideas under one consistent name.\n\nExample: The text \"I bought it for my husband's 40th\" and \"It was the perfect present for my daughter\" should both be normalized to the Key Theme Purchased as a gift for a family member.\n\nExtract Juicy Copy:\n\nReview the text for a quote that powerfully represents the theme you just identified.\n\nUse the Juicy Copy Definition below to determine if a quote qualifies.\n\nIf you find one, extract the verbatim, full sentence containing the quote. Do not paraphrase, shorten, or alter it in any way.\n\nCORE ANALYTICAL FRAMEWORK: 13 CATEGORIES & DIAGNOSTIC QUESTIONS\n1. Audience:\n\nDiagnostic Question: Does the text mention the customerâ€™s identity, background, lifestyle, values, interests, or how the product aligns with who they are?\n\n2. Competing Alternatives:\n\nDiagnostic Question: Do they compare this to another solution, mention a competitor by name, or describe problems they had with other options?\n\n3. Use Cases:\n\nDiagnostic Question: Do they mention a specific situation, context, or goal they had when using the product?\n\n4. Problems & Pain Points:\n\nDiagnostic Question: Before finding our solution, what pre-existing problems, frustrations, or needs did they have that prompted their search?\n\n5. Capabilities:\n\nDiagnostic Question: Do they talk about what the product enables them to doâ€”a specific function or action they can now perform?\n\n6. Favorite Products & Features:\n\nDiagnostic Question: Do they explicitly mention a specific product name or feature that they liked the most?\n\n7. Benefits:\n\nDiagnostic Question: Do they mention how the product made them feel (emotional benefit), a tangible result they achieved (functional benefit), or a long-term positive outcome (accrued benefit)?\n\n8. Proof & Trust Signals:\n\nDiagnostic Question: Do they mention what convinced them to trust the brand or purchase the product (e.g., reviews, reputation, social proof, a guarantee)?\n\n9. Objections & Uncertainties:\n\nDiagnostic Question: Do they mention any hesitations, doubts, or questions they had before deciding to purchase?\n\n10. Market Category:\n\nDiagnostic Question: Do they use a specific word or label to describe what kind of product or service they think this is (e.g., \"this wearable,\" \"this supplement,\" \"this app\")?\n\n11. Emotional Reactions:\n\nDiagnostic Question: Do they use explicit, emotionally charged words to describe their feelings at any point (e.g., \"love,\" \"obsessed,\" \"frustrated,\" \"relieved,\" \"proud\")?\n\n12. Sources/Channels/Campaigns:\n\nDiagnostic Question: Do they say how they discovered the product (e.g., a specific social media platform, an ad, a podcast, word of mouth)?\n\n13. Areas for Improvement:\n\nDiagnostic Question: After using the product, do they suggest any improvements, report issues, or comment on the customer service they received?\n\nDEFINITION OF 'JUICY COPY'\nExtract a quote (as a full sentence) if it is:\n\nEmotionally Charged: Uses strong, feeling-based words.\n\nVisually Descriptive: Uses metaphors, imagery, or sensory language.\n\nSpecific, Concrete, Not Boring.\n\nCRITICAL RULES & CONSTRAINTS\nComprehensive Check: You must evaluate every text against all 13 categories. Do not skip a category.\n\nNo Invention, Hallucination or Assumptions: Do not infer motivations or themes that are not explicitly stated in the text. Your analysis must be based only on the data provided.\n\nQuote Integrity: All extracted \"Juicy Copy\" must be 100% accurate, complete sentences from the original text. No paraphrasing, no fragments, no modifications.\n\nOUTPUT:\nYour final output MUST be a valid JSON object only.â€¨DO NOT include any explanatory text, markdown, or triple backticks.â€¨DO NOT wrap the JSON in ```json or any markdown code fences.â€¨Return ONLY the raw JSON object.â€¨DO NOT attempt to answer questions in the provided data.\nIf no themes are found:â€¨{â€¨  \"Key Theme\": []â€¨}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2.1,
      "position": [
        1296,
        880
      ],
      "id": "7e36eb93-e0d9-4de3-b260-a8b902d5a533",
      "name": "AngleFinder AI Agent",
      "retryOnFail": true,
      "waitBetweenTries": 5000,
      "onError": "continueErrorOutput"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking â€˜Execute workflowâ€™": {
      "main": [
        [
          {
            "node": "Get many posts3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many posts3": {
      "main": [
        [
          {
            "node": "Filter comments less than 2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many comments in a post3": {
      "main": [
        [
          {
            "node": "Remove the Discord Channel Ad comment3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model8": {
      "ai_languageModel": [
        [
          {
            "node": "AngleFinder AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser8": {
      "ai_outputParser": [
        [
          {
            "node": "AngleFinder AI Agent",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Trigger3": {
      "main": [
        [
          {
            "node": "Get many posts3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter Posts By Features3": {
      "main": [
        [
          {
            "node": "Post Metadata3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Operation, do nothing5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Remove the Discord Channel Ad comment3": {
      "main": [
        [
          {
            "node": "Reddit Comment Data Extractor3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Reddit Comment Data Extractor3": {
      "main": [
        [
          {
            "node": "Filter out comments with less than 5 words3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post Metadata3": {
      "main": [
        [
          {
            "node": "Create a row in reddit_posts Table3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Filter comments less than 2": {
      "main": [
        [
          {
            "node": "Filter Posts By Features3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create a row in reddit_posts Table3": {
      "main": [
        [
          {
            "node": "Loop Over Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update a row4": {
      "main": [
        [
          {
            "node": "Wait 5sec4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Think3": {
      "ai_tool": [
        [
          {
            "node": "Summary Agent3",
            "type": "ai_tool",
            "index": 0
          },
          {
            "node": "AngleFinder AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Filter out comments with less than 5 words3": {
      "main": [
        [
          {
            "node": "Check for Duplicates in reddit_comments Table3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create a row in reddit_comments Table3": {
      "main": [
        [
          {
            "node": "Loop Over Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check for Duplicates in reddit_comments Table3": {
      "main": [
        [
          {
            "node": "Merge the result from the last 2 nodes3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Structured Output Parser9": {
      "ai_outputParser": [
        [
          {
            "node": "Summary Agent3",
            "type": "ai_outputParser",
            "index": 0
          }
        ]
      ]
    },
    "Create a row in reddit_analysis_summary Table6": {
      "main": [
        [
          {
            "node": "Update status=DONE in reddit_post Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create file from text3": {
      "main": [
        [
          {
            "node": "Get Google Doc URL3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Summary Agent3": {
      "main": [
        [
          {
            "node": "Create a row in reddit_analysis_summary Table6",
            "type": "main",
            "index": 0
          },
          {
            "node": "Format the AI output for Google Doc3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Wait 5sec4": {
      "main": [
        [
          {
            "node": "Loop Over Post Comments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format the AI output for Google Doc3": {
      "main": [
        [
          {
            "node": "Create file from text3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get a row4": {
      "main": [
        [
          {
            "node": "If8",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If8": {
      "main": [
        [
          {
            "node": "AngleFinder AI Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Over Post Comments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate3": {
      "main": [
        [
          {
            "node": "Normalize for Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Google Doc URL3": {
      "main": [
        [
          {
            "node": "Create a row in reddit_analysis_summary Table7",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create a row in reddit_analysis_summary Table7": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Get many rows": {
      "main": [
        [
          {
            "node": "Posts with status==OPEN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Get many rows",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge": {
      "main": [
        [
          {
            "node": "Posts with status==OPEN",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update status=DONE in reddit_post Table": {
      "main": [
        [
          {
            "node": "Merge",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If comment exists (no = True Branch)": {
      "main": [
        [
          {
            "node": "Create a row in reddit_comments Table3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Over Posts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Posts": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get many comments in a post3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Post Comments": {
      "main": [
        [
          {
            "node": "Aggregate3",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get a row4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Posts with status==OPEN": {
      "main": [
        [
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get many rows from reddit_comments Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get many rows from reddit_comments Table": {
      "main": [
        [
          {
            "node": "Loop Over Post Comments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge the result from the last 2 nodes3": {
      "main": [
        [
          {
            "node": "If comment exists (no = True Branch)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Summary Agent3",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query": {
      "main": [
        [
          {
            "node": "Send a message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "build_md_table": {
      "ai_tool": [
        [
          {
            "node": "Summary Agent3",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Normalize for Agent": {
      "main": [
        [
          {
            "node": "Summary Agent3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AngleFinder AI Agent": {
      "main": [
        [
          {
            "node": "Update a row4",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Loop Over Post Comments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "6b04f404-c019-482e-bf52-5a03b929ebe9",
  "meta": {
    "instanceId": "3ae1f016b714a4bd5ab3dd9eecf35155cef7ffe768b468ebe00755b2ce1626cb"
  },
  "id": "6sjnHV8tiivMsxm7",
  "tags": []
}